# USER_MANUAL_20250831: 한국 주식 트레이딩 시스템 완전 사용자 매뉴얼

작성일: 2025-08-31  
버전: 2.0  
대상: 초보자부터 전문가까지

## 📋 목차

1. [시스템 개요](#1-시스템-개요)
2. [설치 및 초기 설정](#2-설치-및-초기-설정)
3. [Docker 환경 구성](#3-docker-환경-구성)
4. [데이터 수집 시스템](#4-데이터-수집-시스템)
5. [웹 애플리케이션 사용법](#5-웹-애플리케이션-사용법)
6. [데이터베이스 접속 및 쿼리](#6-데이터베이스-접속-및-쿼리)
7. [Grafana 대시보드 사용법](#7-grafana-대시보드-사용법)
8. [API 엔드포인트 활용](#8-api-엔드포인트-활용)
9. [배치 작업 및 스케줄링](#9-배치-작업-및-스케줄링)
10. [문제 해결 가이드](#10-문제-해결-가이드)

---

## 1. 시스템 개요

### 1.1 시스템 구성요소

한국 주식 트레이딩 시스템은 다음과 같은 구성요소로 이루어져 있습니다:

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Web Frontend  │    │  FastAPI Backend│    │  Data Collector │
│   (React/HTML)  │◄──►│   (Python)      │◄──►│    (pykrx)      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │
                                ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│    Grafana      │◄──►│   PostgreSQL    │◄──►│    InfluxDB     │
│  (시각화/대시보드) │    │ (메인 데이터베이스) │    │   (시계열 DB)   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                │
                                ▼
                       ┌─────────────────┐
                       │      Redis      │
                       │   (캐시/큐)     │
                       └─────────────────┘
```

### 1.2 주요 기능

- **실시간 주식 데이터 수집**: 한국 전체 주식 (KOSPI/KOSDAQ)
- **5년 히스토리 데이터**: 일별 OHLCV 및 재무지표
- **자동 섹터/업종 분류**: 11개 대분류, 동적 소분류
- **포트폴리오 시뮬레이션**: 백테스팅 및 성과 분석  
- **대시보드 시각화**: Grafana 기반 실시간 차트
- **RESTful API**: 외부 연동 및 커스텀 애플리케이션

---

## 2. 설치 및 초기 설정

### 2.1 시스템 요구사항

**하드웨어 요구사항:**
- CPU: Intel i5 이상 또는 동급
- RAM: 8GB 이상 (16GB 권장)
- Storage: 20GB 이상 여유 공간
- Network: 안정적인 인터넷 연결

**소프트웨어 요구사항:**
- OS: Windows 10/11, macOS, Linux
- Docker Desktop 4.0 이상
- Python 3.8 이상 (옵션)
- Git (코드 다운로드용)

### 2.2 프로젝트 다운로드

```bash
# Git을 사용한 다운로드
git clone <repository-url> stock-trading-system
cd stock-trading-system

# 또는 ZIP 파일 다운로드 후 압축 해제
# stock-trading-system 폴더로 이동
```

### 2.3 환경변수 설정

`.env.example` 파일을 복사하여 `.env` 파일 생성:

```bash
# Windows
copy .env.example .env

# macOS/Linux  
cp .env.example .env
```

`.env` 파일 내용 수정:
```env
# 데이터베이스 설정
DATABASE_URL=postgresql://admin:admin123@localhost:5435/stocktrading
REDIS_URL=redis://localhost:6380
INFLUXDB_URL=http://localhost:8086
INFLUXDB_TOKEN=my-super-secret-auth-token

# API 설정
JWT_SECRET_KEY=your-super-secret-jwt-key-here
API_HOST=0.0.0.0
API_PORT=8000

# 데이터 수집 설정
STOCK_DATA_UPDATE_INTERVAL=3600  # 1시간마다
ENABLE_REAL_TIME=true
```

---

## 3. Docker 환경 구성

### 3.1 Docker Desktop 설치 확인

```bash
# Docker 버전 확인
docker --version
docker-compose --version

# Docker가 실행 중인지 확인
docker ps
```

### 3.2 전체 시스템 기동

**한번에 모든 서비스 시작:**
```bash
# Windows
start.bat

# macOS/Linux
chmod +x start.sh
./start.sh

# 또는 직접 Docker Compose 실행
docker-compose up -d
```

**개별 서비스 기동 순서:**
```bash
# 1. 데이터베이스 서비스 먼저 시작
docker-compose up -d postgres redis influxdb

# 2. 30초 대기 후 애플리케이션 서비스
docker-compose up -d backend celery-worker celery-beat

# 3. 프론트엔드 및 모니터링
docker-compose up -d grafana frontend
```

### 3.3 서비스 상태 확인

```bash
# 모든 컨테이너 상태 확인
docker-compose ps

# 로그 확인
docker-compose logs backend
docker-compose logs postgres
docker-compose logs grafana

# 특정 컨테이너 내부 접속
docker exec -it stock-backend bash
docker exec -it stock-db psql -U admin -d stocktrading
```

### 3.4 포트 정보

| 서비스 | 포트 | 접속 URL | 설명 |
|--------|------|----------|------|
| Frontend | 3000 | http://localhost:3000 | 웹 인터페이스 |
| Backend API | 8000 | http://localhost:8000 | REST API |
| Grafana | 3030 | http://localhost:3030 | 대시보드 |
| PostgreSQL | 5435 | localhost:5435 | 메인 DB |
| InfluxDB | 8086 | http://localhost:8086 | 시계열 DB |
| Redis | 6380 | localhost:6380 | 캐시 서버 |

---

## 4. 데이터 수집 시스템

### 4.1 초기 데이터 수집 (필수)

**전체 5년 데이터 수집:**
```bash
# Windows에서 간편 실행
fetch_korea_stocks.bat

# Docker 환경에서 직접 실행
docker exec stock-backend python fetch_korea_stocks.py --years 5

# 진행상황 모니터링
docker logs -f stock-backend
```

**수집 진행 상황 확인:**
```bash
# PostgreSQL에서 진행 상황 확인
docker exec stock-db psql -U admin -d stocktrading -c "
SELECT 
    COUNT(*) as total_records,
    COUNT(DISTINCT ticker) as unique_stocks,
    MAX(created_at) as latest_update
FROM stock_prices;"

# 섹터별 수집 현황
docker exec stock-db psql -U admin -d stocktrading -c "
SELECT 
    s.sector_name,
    COUNT(*) as stock_count
FROM stock_details s 
WHERE s.sector_name IS NOT NULL
GROUP BY s.sector_name
ORDER BY stock_count DESC;"
```

### 4.2 데이터 수집 옵션

**부분 업데이트 (일일 운영):**
```bash
# 최근 30일 데이터만 업데이트
docker exec stock-backend python fetch_korea_stocks.py --update-only --days 30

# 특정 기간 설정
docker exec stock-backend python fetch_korea_stocks.py --update-only --days 7
```

**특정 종목만 수집:**
```bash
# 특정 종목 테스트
docker exec stock-backend python test_single_stock.py

# 주요 종목만 수집 (커스텀 스크립트 작성 필요)
docker exec stock-backend python collect_major_stocks.py
```

### 4.3 데이터 수집 모니터링

**실시간 로그 모니터링:**
```bash
# 수집 로그 실시간 확인
docker logs -f stock-backend | grep "INFO"

# 에러 로그만 확인
docker logs stock-backend | grep "ERROR"

# 특정 시간 이후 로그
docker logs --since="1h" stock-backend
```

**진행률 체크 쿼리:**
```sql
-- DBeaver나 psql에서 실행
-- 전체 진행률 확인
SELECT 
    market_type,
    COUNT(DISTINCT s.ticker) as total_stocks,
    COUNT(DISTINCT sp.ticker) as collected_stocks,
    ROUND(COUNT(DISTINCT sp.ticker) * 100.0 / COUNT(DISTINCT s.ticker), 2) as completion_rate
FROM stocks s
LEFT JOIN stock_prices sp ON s.ticker = sp.ticker
GROUP BY market_type;
```

---

## 5. 웹 애플리케이션 사용법

### 5.1 웹 인터페이스 접속

1. 브라우저에서 http://localhost:3000 접속
2. 회원가입 또는 로그인
3. 대시보드 확인

### 5.2 주요 기능 사용법

**종목 검색 및 조회:**
1. 상단 검색창에 종목명 또는 코드 입력 (예: "삼성전자" 또는 "005930")
2. 검색 결과에서 원하는 종목 클릭
3. 종목 상세 페이지에서 다음 정보 확인:
   - 기본 정보 (섹터, 업종, 시가총액)
   - 5년 차트 (일봉, 주봉, 월봉)
   - 재무지표 (PER, PBR, EPS, BPS)
   - 기술적 지표 (이동평균, RSI, MACD)

**포트폴리오 생성:**
1. "포트폴리오" 메뉴 클릭
2. "새 포트폴리오 생성" 버튼
3. 포트폴리오 이름 입력
4. "종목 추가" 버튼으로 원하는 종목들 추가
5. 각 종목별 비중 설정
6. "저장" 클릭

**백테스팅 실행:**
1. 포트폴리오 선택
2. "백테스팅" 탭 클릭
3. 테스트 기간 설정 (시작일, 종료일)
4. 초기 투자금액 설정
5. 리밸런싱 주기 선택 (월별, 분기별, 연별)
6. "백테스팅 실행" 버튼 클릭
7. 결과 분석:
   - 총 수익률
   - 연평균 수익률
   - 최대 손실률 (MDD)
   - 샤프 비율
   - 변동성

**스크리닝 기능:**
1. "스크리너" 메뉴 접속
2. 필터 조건 설정:
   - 시가총액 범위
   - PER 범위  
   - PBR 범위
   - 섹터 선택
   - 수익률 조건
3. "검색" 버튼 클릭
4. 결과를 엑셀로 내보내기 가능

### 5.3 알림 및 설정

**가격 알림 설정:**
1. 종목 상세 페이지에서 "알림 설정" 클릭
2. 알림 조건 입력:
   - 목표가 도달 시
   - 변동률 기준 (예: ±5% 이상 변동)
   - 거래량 급증 시
3. 알림 방식 선택 (이메일, 브라우저 알림)

---

## 6. 데이터베이스 접속 및 쿼리

### 6.1 DBeaver를 이용한 DB 접속

**DBeaver 설정:**
1. DBeaver 다운로드 및 설치: https://dbeaver.io/
2. "새 연결" → "PostgreSQL" 선택
3. 연결 정보 입력:
   - **Host**: localhost
   - **Port**: 5435
   - **Database**: stocktrading  
   - **Username**: admin
   - **Password**: admin123
4. "연결 테스트" → "확인" → "완료"

### 6.2 핵심 테이블 구조

**stocks (종목 정보):**
```sql
SELECT * FROM stocks LIMIT 5;
-- ticker, company_name, market_type, sector_id, industry_id, market_cap
```

**stock_prices (가격 데이터):**
```sql
SELECT * FROM stock_prices WHERE ticker = '005930' ORDER BY date DESC LIMIT 10;
-- ticker, date, open_price, high_price, low_price, close_price, volume
```

**sectors & industries (섹터/업종):**
```sql
-- 섹터별 종목 수
SELECT s.name as sector, COUNT(st.ticker) as stock_count
FROM sectors s
LEFT JOIN stocks st ON s.id = st.sector_id
GROUP BY s.name
ORDER BY stock_count DESC;
```

### 6.3 자주 사용하는 쿼리

**1. 종목별 최근 성과 조회:**
```sql
WITH recent_prices AS (
    SELECT 
        ticker,
        close_price,
        LAG(close_price, 20) OVER (PARTITION BY ticker ORDER BY date) as price_20d_ago,
        ROW_NUMBER() OVER (PARTITION BY ticker ORDER BY date DESC) as rn
    FROM stock_prices
    WHERE date >= CURRENT_DATE - INTERVAL '30 days'
)
SELECT 
    s.ticker,
    s.company_name,
    sec.name as sector,
    ind.name as industry,
    r.close_price as current_price,
    r.price_20d_ago,
    ROUND(((r.close_price - r.price_20d_ago) / r.price_20d_ago * 100), 2) as return_20d
FROM recent_prices r
JOIN stocks s ON r.ticker = s.ticker
LEFT JOIN sectors sec ON s.sector_id = sec.id
LEFT JOIN industries ind ON s.industry_id = ind.id
WHERE r.rn = 1 AND r.price_20d_ago IS NOT NULL
ORDER BY return_20d DESC
LIMIT 20;
```

**2. 섹터별 평균 수익률:**
```sql
WITH sector_returns AS (
    SELECT 
        s.ticker,
        sec.name as sector_name,
        FIRST_VALUE(sp.close_price) OVER (PARTITION BY s.ticker ORDER BY sp.date DESC) as latest_price,
        FIRST_VALUE(sp.close_price) OVER (PARTITION BY s.ticker ORDER BY sp.date ASC) as first_price
    FROM stocks s
    JOIN stock_prices sp ON s.ticker = sp.ticker
    LEFT JOIN sectors sec ON s.sector_id = sec.id
    WHERE sp.date >= CURRENT_DATE - INTERVAL '1 year'
)
SELECT 
    sector_name,
    COUNT(DISTINCT ticker) as stock_count,
    ROUND(AVG((latest_price - first_price) / first_price * 100), 2) as avg_return_1y
FROM sector_returns
WHERE sector_name IS NOT NULL
GROUP BY sector_name
ORDER BY avg_return_1y DESC;
```

**3. 고배당 종목 스크리닝:**
```sql
SELECT 
    s.ticker,
    s.company_name,
    sec.name as sector,
    sf.dividend_yield,
    sf.per,
    sf.pbr,
    sp.close_price
FROM stocks s
JOIN stock_fundamentals sf ON s.ticker = sf.ticker
JOIN stock_prices sp ON s.ticker = sp.ticker
LEFT JOIN sectors sec ON s.sector_id = sec.id
WHERE sf.date = (SELECT MAX(date) FROM stock_fundamentals WHERE ticker = s.ticker)
  AND sp.date = (SELECT MAX(date) FROM stock_prices WHERE ticker = s.ticker)
  AND sf.dividend_yield > 3.0  -- 배당수익률 3% 이상
  AND sf.per > 0 AND sf.per < 15  -- PER 15 이하
  AND s.market_cap > 1000000000000  -- 시가총액 1조 이상
ORDER BY sf.dividend_yield DESC
LIMIT 30;
```

**4. 기술적 분석 - 이동평균 돌파:**
```sql
WITH moving_averages AS (
    SELECT 
        ticker,
        date,
        close_price,
        AVG(close_price) OVER (PARTITION BY ticker ORDER BY date ROWS BETWEEN 19 PRECEDING AND CURRENT ROW) as ma20,
        AVG(close_price) OVER (PARTITION BY ticker ORDER BY date ROWS BETWEEN 59 PRECEDING AND CURRENT ROW) as ma60
    FROM stock_prices
    WHERE date >= CURRENT_DATE - INTERVAL '3 months'
),
latest_ma AS (
    SELECT 
        ticker,
        close_price,
        ma20,
        ma60,
        ROW_NUMBER() OVER (PARTITION BY ticker ORDER BY date DESC) as rn
    FROM moving_averages
    WHERE ma20 IS NOT NULL AND ma60 IS NOT NULL
)
SELECT 
    s.ticker,
    s.company_name,
    sec.name as sector,
    lma.close_price,
    ROUND(lma.ma20, 2) as ma20,
    ROUND(lma.ma60, 2) as ma60,
    CASE 
        WHEN lma.close_price > lma.ma20 AND lma.ma20 > lma.ma60 THEN '강세'
        WHEN lma.close_price < lma.ma20 AND lma.ma20 < lma.ma60 THEN '약세'
        ELSE '보합'
    END as trend
FROM latest_ma lma
JOIN stocks s ON lma.ticker = s.ticker
LEFT JOIN sectors sec ON s.sector_id = sec.id
WHERE lma.rn = 1
  AND lma.close_price > lma.ma20 
  AND lma.ma20 > lma.ma60  -- 골든크로스 패턴
ORDER BY s.market_cap DESC
LIMIT 50;
```

### 6.4 데이터 내보내기

**CSV 내보내기:**
```sql
-- DBeaver에서 쿼리 실행 후
-- 결과창에서 우클릭 → "Export Data" → "CSV" 선택

\COPY (SELECT * FROM stock_details) TO '/path/to/export.csv' WITH CSV HEADER;
```

---

## 7. Grafana 대시보드 사용법

### 7.1 Grafana 접속 및 초기 설정

**접속 정보:**
- URL: http://localhost:3030
- Username: admin  
- Password: admin123

**초기 설정:**
1. 로그인 후 "Add your first data source" 클릭
2. PostgreSQL 선택
3. 연결 정보 입력:
   - Host: postgres:5432
   - Database: stocktrading
   - User: admin
   - Password: admin123
4. "Save & Test" 클릭

### 7.2 대시보드 가져오기

**기본 대시보드 가져오기:**
1. 좌측 메뉴 "+" → "Import" 클릭
2. `import-dashboard.json` 파일 업로드
3. 데이터 소스 선택: PostgreSQL
4. "Import" 클릭

### 7.3 커스텀 대시보드 생성

**새 대시보드 만들기:**
1. "+" → "Dashboard" → "Add new panel"
2. 쿼리 작성 예시:

**종목별 일별 수익률:**
```sql
SELECT 
    date as time,
    ticker as metric,
    ((close_price - LAG(close_price) OVER (ORDER BY date)) / LAG(close_price) OVER (ORDER BY date) * 100) as value
FROM stock_prices 
WHERE ticker IN ('005930', '000660', '035420')
  AND date >= now() - interval '3 months'
ORDER BY time;
```

**섹터별 시가총액:**
```sql
SELECT 
    s.name as metric,
    SUM(st.market_cap) as value,
    NOW() as time
FROM sectors s
JOIN stocks st ON s.id = st.sector_id
WHERE st.market_cap IS NOT NULL
GROUP BY s.name;
```

### 7.4 알림 설정

**가격 알림 생성:**
1. Panel Edit → "Alert" 탭
2. "Create Alert" 클릭
3. 조건 설정:
   ```
   WHEN avg() OF query(A, 5m, now) IS ABOVE 100000
   ```
4. 알림 채널 설정 (이메일, Slack 등)

### 7.5 실시간 모니터링 패널

**실시간 가격 추적:**
```sql
-- Query A: 실시간 가격
SELECT 
    EXTRACT(EPOCH FROM created_at)*1000 as time,
    ticker as metric,
    close_price as value
FROM stock_prices 
WHERE ticker = '005930'
  AND created_at >= now() - interval '1 day'
ORDER BY time;
```

**거래량 급증 탐지:**
```sql
-- Query B: 거래량 비교
WITH avg_volume AS (
    SELECT 
        ticker,
        AVG(volume) as avg_vol_30d
    FROM stock_prices
    WHERE date >= CURRENT_DATE - INTERVAL '30 days'
    GROUP BY ticker
)
SELECT 
    sp.ticker as metric,
    (sp.volume / av.avg_vol_30d) as value,
    EXTRACT(EPOCH FROM sp.created_at)*1000 as time
FROM stock_prices sp
JOIN avg_volume av ON sp.ticker = av.ticker
WHERE sp.date = CURRENT_DATE
  AND sp.volume > av.avg_vol_30d * 2  -- 평균 거래량의 2배 이상
ORDER BY value DESC;
```

---

## 8. API 엔드포인트 활용

### 8.1 API 문서 확인

**Swagger UI 접속:**
- URL: http://localhost:8000/docs
- 모든 API 엔드포인트와 사용법 확인 가능

### 8.2 주요 API 엔드포인트

**인증:**
```bash
# 회원가입
curl -X POST "http://localhost:8000/auth/register" \
  -H "Content-Type: application/json" \
  -d '{"username": "testuser", "email": "test@example.com", "password": "password123"}'

# 로그인 (토큰 받기)
curl -X POST "http://localhost:8000/auth/login" \
  -H "Content-Type: application/json" \
  -d '{"username": "testuser", "password": "password123"}'
```

**종목 정보 조회:**
```bash
# 전체 종목 리스트
curl "http://localhost:8000/api/stocks/"

# 특정 종목 상세정보
curl "http://localhost:8000/api/stocks/005930"

# 섹터별 종목 조회
curl "http://localhost:8000/api/stocks/sector/IT"

# 가격 데이터 조회
curl "http://localhost:8000/api/stocks/005930/prices?start_date=2024-01-01&end_date=2024-12-31"
```

**포트폴리오 관리:**
```bash
# 포트폴리오 생성 (인증 필요)
curl -X POST "http://localhost:8000/api/portfolios/" \
  -H "Authorization: Bearer YOUR_TOKEN_HERE" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "My Portfolio",
    "description": "Tech stocks portfolio",
    "stocks": [
      {"ticker": "005930", "weight": 0.4},
      {"ticker": "035420", "weight": 0.3},
      {"ticker": "000660", "weight": 0.3}
    ]
  }'

# 백테스팅 실행
curl -X POST "http://localhost:8000/api/portfolios/1/backtest" \
  -H "Authorization: Bearer YOUR_TOKEN_HERE" \
  -H "Content-Type: application/json" \
  -d '{
    "start_date": "2020-01-01",
    "end_date": "2024-12-31",
    "initial_capital": 10000000,
    "rebalancing": "monthly"
  }'
```

### 8.3 Python을 이용한 API 활용

**Python 클라이언트 예시:**
```python
import requests
import pandas as pd
from datetime import datetime, timedelta

class StockAPIClient:
    def __init__(self, base_url="http://localhost:8000"):
        self.base_url = base_url
        self.token = None
    
    def login(self, username, password):
        """로그인 및 토큰 획득"""
        response = requests.post(
            f"{self.base_url}/auth/login",
            json={"username": username, "password": password}
        )
        if response.status_code == 200:
            self.token = response.json()["access_token"]
            return True
        return False
    
    def get_headers(self):
        """인증 헤더 반환"""
        if self.token:
            return {"Authorization": f"Bearer {self.token}"}
        return {}
    
    def get_stock_info(self, ticker):
        """종목 정보 조회"""
        response = requests.get(f"{self.base_url}/api/stocks/{ticker}")
        return response.json() if response.status_code == 200 else None
    
    def get_price_data(self, ticker, start_date, end_date):
        """가격 데이터 조회"""
        params = {
            "start_date": start_date,
            "end_date": end_date
        }
        response = requests.get(
            f"{self.base_url}/api/stocks/{ticker}/prices",
            params=params
        )
        if response.status_code == 200:
            return pd.DataFrame(response.json())
        return None
    
    def screen_stocks(self, criteria):
        """종목 스크리닝"""
        response = requests.post(
            f"{self.base_url}/api/stocks/screen",
            json=criteria,
            headers=self.get_headers()
        )
        return response.json() if response.status_code == 200 else None

# 사용 예시
client = StockAPIClient()

# 종목 정보 조회
stock_info = client.get_stock_info("005930")
print(f"Company: {stock_info['company_name']}")
print(f"Sector: {stock_info['sector_name']}")

# 가격 데이터 조회
prices = client.get_price_data(
    "005930", 
    "2024-01-01", 
    "2024-12-31"
)
print(f"Price data shape: {prices.shape}")
print(prices.head())

# 스크리닝 (로그인 필요)
if client.login("your_username", "your_password"):
    criteria = {
        "market_cap_min": 1000000000000,  # 1조 이상
        "per_max": 15,
        "dividend_yield_min": 3.0,
        "sector": "IT"
    }
    results = client.screen_stocks(criteria)
    print(f"Found {len(results)} stocks matching criteria")
```

---

## 9. 배치 작업 및 스케줄링

### 9.1 Celery를 이용한 배치 작업

**Celery 워커 상태 확인:**
```bash
# 워커 상태 확인
docker exec stock-celery-worker celery -A celery_app status

# 활성 작업 조회
docker exec stock-celery-worker celery -A celery_app active

# 예약된 작업 조회
docker exec stock-celery-beat celery -A celery_app inspect scheduled
```

**수동 작업 실행:**
```python
# Python 콘솔에서
from celery_app import update_stock_prices, calculate_technical_indicators

# 특정 종목 가격 업데이트
result = update_stock_prices.delay("005930")
print(f"Task ID: {result.id}")

# 기술적 지표 계산
result = calculate_technical_indicators.delay()
print(f"Task ID: {result.id}")
```

### 9.2 데이터 업데이트 스케줄

**기본 스케줄 (celery_app.py에 설정됨):**
```python
from celery.schedules import crontab

app.conf.beat_schedule = {
    # 매일 장마감 후 가격 데이터 업데이트 (18:00)
    'daily-price-update': {
        'task': 'update_daily_prices',
        'schedule': crontab(hour=18, minute=0),
    },
    
    # 매주 월요일 기술적 지표 계산 (09:00)
    'weekly-technical-indicators': {
        'task': 'calculate_technical_indicators', 
        'schedule': crontab(hour=9, minute=0, day_of_week=1),
    },
    
    # 매월 1일 재무제표 업데이트 (10:00)
    'monthly-fundamental-update': {
        'task': 'update_fundamentals',
        'schedule': crontab(hour=10, minute=0, day_of_month=1),
    }
}
```

### 9.3 Windows 작업 스케줄러 설정

**일별 데이터 업데이트 스케줄러 생성:**
```cmd
# 관리자 권한으로 실행
schtasks /create ^
  /tn "Stock Data Daily Update" ^
  /tr "C:\path\to\stock-trading-system\daily_update.bat" ^
  /sc daily ^
  /st 18:30 ^
  /ru SYSTEM

# 스케줄러 확인
schtasks /query /tn "Stock Data Daily Update"

# 스케줄러 삭제 (필요시)
schtasks /delete /tn "Stock Data Daily Update" /f
```

**daily_update.bat 내용:**
```batch
@echo off
cd /d "C:\path\to\stock-trading-system"
docker-compose exec -T backend python fetch_korea_stocks.py --update-only --days 1
echo %date% %time% - Daily update completed >> update_log.txt
```

### 9.4 Linux/macOS Cron 작업 설정

**Crontab 편집:**
```bash
# Crontab 편집
crontab -e

# 다음 내용 추가
# 매일 오후 6시 30분에 데이터 업데이트
30 18 * * * /path/to/stock-trading-system/daily_update.sh >> /var/log/stock_update.log 2>&1

# 매주 일요일 오전 2시에 전체 시스템 재시작
0 2 * * 0 /path/to/stock-trading-system/restart_system.sh

# Crontab 확인
crontab -l
```

**daily_update.sh 내용:**
```bash
#!/bin/bash
cd /path/to/stock-trading-system
docker-compose exec -T backend python fetch_korea_stocks.py --update-only --days 1
echo "$(date) - Daily update completed"
```

---

## 10. 문제 해결 가이드

### 10.1 일반적인 문제들

**1. Docker 서비스 시작 실패:**
```bash
# 문제: 포트 충돌
# 해결: 사용 중인 포트 확인
netstat -tulpn | grep :5432
netstat -tulpn | grep :3000

# 해결: docker-compose.yml에서 포트 변경
# postgres:
#   ports:
#     - "5436:5432"  # 5435 대신 5436 사용
```

**2. 데이터베이스 연결 실패:**
```bash
# 문제 진단
docker logs stock-db
docker exec stock-db pg_isready -U admin

# 해결 방법
# 1. 컨테이너 재시작
docker-compose restart postgres

# 2. 볼륨 재생성 (데이터 손실 주의!)
docker-compose down -v
docker-compose up -d
```

**3. 데이터 수집 실패:**
```bash
# 로그 확인
docker logs stock-backend | grep ERROR

# 네트워크 연결 확인
docker exec stock-backend ping api.krx.co.kr

# pykrx 업데이트
docker exec stock-backend pip install --upgrade pykrx
```

### 10.2 성능 문제

**1. 쿼리 성능 개선:**
```sql
-- 인덱스 확인
SELECT indexname, indexdef FROM pg_indexes WHERE tablename = 'stock_prices';

-- 누락된 인덱스 생성
CREATE INDEX idx_stock_prices_ticker_date ON stock_prices(ticker, date DESC);
CREATE INDEX idx_stock_prices_created_at ON stock_prices(created_at);

-- 쿼리 실행 계획 확인
EXPLAIN ANALYZE SELECT * FROM stock_prices WHERE ticker = '005930' ORDER BY date DESC LIMIT 100;
```

**2. 메모리 사용량 최적화:**
```bash
# 메모리 사용량 확인
docker stats

# PostgreSQL 메모리 설정 조정 (docker-compose.yml)
# postgres:
#   command: postgres -c shared_buffers=256MB -c effective_cache_size=1GB
```

**3. 디스크 공간 관리:**
```bash
# 디스크 사용량 확인
docker system df
docker volume ls

# 불필요한 데이터 정리
docker system prune
docker volume prune

# 오래된 로그 삭제
docker logs stock-backend 2>/dev/null | wc -l
docker-compose logs --tail=1000 backend > recent_logs.txt
```

### 10.3 데이터 품질 문제

**1. 중복 데이터 확인 및 제거:**
```sql
-- 중복 확인
SELECT ticker, date, COUNT(*)
FROM stock_prices
GROUP BY ticker, date
HAVING COUNT(*) > 1;

-- 중복 제거 (최신 created_at 유지)
DELETE FROM stock_prices
WHERE id NOT IN (
    SELECT MAX(id)
    FROM stock_prices
    GROUP BY ticker, date
);
```

**2. 누락 데이터 확인:**
```sql
-- 거래일별 데이터 완성도 확인
WITH trading_days AS (
    SELECT DISTINCT date
    FROM stock_prices
    WHERE date >= '2024-01-01'
    ORDER BY date
),
stock_count AS (
    SELECT date, COUNT(*) as stock_count
    FROM stock_prices
    WHERE date >= '2024-01-01'
    GROUP BY date
)
SELECT 
    td.date,
    COALESCE(sc.stock_count, 0) as collected_stocks,
    (SELECT COUNT(*) FROM stocks WHERE is_active = true) as total_stocks
FROM trading_days td
LEFT JOIN stock_count sc ON td.date = sc.date
ORDER BY td.date DESC;
```

**3. 이상값 탐지:**
```sql
-- 가격 급등/급락 종목 확인
WITH price_changes AS (
    SELECT 
        ticker,
        date,
        close_price,
        LAG(close_price) OVER (PARTITION BY ticker ORDER BY date) as prev_close,
        ((close_price - LAG(close_price) OVER (PARTITION BY ticker ORDER BY date)) 
         / LAG(close_price) OVER (PARTITION BY ticker ORDER BY date) * 100) as change_pct
    FROM stock_prices
    WHERE date >= CURRENT_DATE - INTERVAL '7 days'
)
SELECT 
    s.ticker,
    s.company_name,
    pc.date,
    pc.close_price,
    pc.prev_close,
    ROUND(pc.change_pct, 2) as change_pct
FROM price_changes pc
JOIN stocks s ON pc.ticker = s.ticker
WHERE ABS(pc.change_pct) > 30  -- 30% 이상 변동
ORDER BY ABS(pc.change_pct) DESC;
```

### 10.4 백업 및 복구

**1. 데이터베이스 백업:**
```bash
# 전체 데이터베이스 백업
docker exec stock-db pg_dump -U admin stocktrading > backup_$(date +%Y%m%d).sql

# 특정 테이블만 백업
docker exec stock-db pg_dump -U admin -t stock_prices stocktrading > stock_prices_backup.sql

# 압축 백업
docker exec stock-db pg_dump -U admin stocktrading | gzip > backup_$(date +%Y%m%d).sql.gz
```

**2. 데이터베이스 복구:**
```bash
# 백업 파일로부터 복구
docker exec -i stock-db psql -U admin stocktrading < backup_20250831.sql

# 압축 파일로부터 복구
gunzip -c backup_20250831.sql.gz | docker exec -i stock-db psql -U admin stocktrading
```

**3. 설정 파일 백업:**
```bash
# 중요 설정 파일들 백업
tar czf config_backup_$(date +%Y%m%d).tar.gz \
  docker-compose.yml \
  .env \
  backend/config.py \
  database/init.sql
```

### 10.5 모니터링 및 알림

**1. 시스템 상태 모니터링 스크립트:**
```bash
#!/bin/bash
# health_check.sh

echo "=== Stock Trading System Health Check ===" 
echo "Date: $(date)"

# Docker 서비스 상태 확인
echo -e "\n1. Docker Services Status:"
docker-compose ps

# 데이터베이스 연결 확인
echo -e "\n2. Database Connection:"
docker exec stock-db pg_isready -U admin && echo "✓ PostgreSQL is ready" || echo "✗ PostgreSQL connection failed"

# 최근 데이터 수집 상태 확인
echo -e "\n3. Recent Data Collection:"
LATEST_DATA=$(docker exec stock-db psql -U admin -d stocktrading -t -c "SELECT MAX(created_at) FROM stock_prices;")
echo "Latest data: $LATEST_DATA"

# API 서비스 확인
echo -e "\n4. API Service Status:"
curl -s http://localhost:8000/health && echo "✓ API is responsive" || echo "✗ API is not responding"

# Grafana 서비스 확인  
echo -e "\n5. Grafana Service:"
curl -s http://localhost:3030/api/health && echo "✓ Grafana is responsive" || echo "✗ Grafana is not responding"

echo -e "\n=== Health Check Completed ==="
```

**2. 디스크 공간 모니터링:**
```bash
#!/bin/bash
# disk_monitor.sh

THRESHOLD=80  # 80% 이상 사용 시 알림

USAGE=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')

if [ $USAGE -gt $THRESHOLD ]; then
    echo "WARNING: Disk usage is ${USAGE}% (threshold: ${THRESHOLD}%)"
    
    # 로그 파일 정리
    docker system prune -f
    
    # 이메일 알림 (optional)
    # echo "Disk usage: ${USAGE}%" | mail -s "Disk Space Alert" admin@company.com
fi
```

---

## 📚 추가 리소스

### 참고 문서
- [pykrx 공식 문서](https://github.com/sharebook-kr/pykrx)
- [FastAPI 공식 문서](https://fastapi.tiangolo.com/)
- [Grafana 공식 문서](https://grafana.com/docs/)
- [PostgreSQL 공식 문서](https://www.postgresql.org/docs/)

### 커뮤니티 및 지원
- GitHub Issues: 버그 리포트 및 기능 요청
- Discord 커뮤니티: 실시간 질의응답
- 블로그 튜토리얼: 고급 사용법 및 팁

### 라이선스 및 면책사항
본 시스템은 교육 및 연구 목적으로 제공됩니다. 실제 투자 결정에 사용하기 전에 충분한 검토와 테스트를 수행하시기 바랍니다. 투자 손실에 대한 책임은 사용자에게 있습니다.

---

**문서 버전**: 2.0  
**최종 업데이트**: 2025-08-31  
**작성자**: Stock Trading System Development Team