# 스크리닝 탭 UI 개선 및 매매신호 연동

**작업일**: 2025-10-08
**작업자**: Claude Code
**브랜치**: screening-backtesting-improvement
**커밋**: a06cee8

---

## 📋 작업 개요

스크리닝 탭의 사용성을 개선하고, 스크리닝 결과를 매매신호 탭과 연동하는 기능을 구현했습니다.

---

## 🎯 작업 목표

1. 스크리닝 탭 UI를 종목관리 탭 형태로 변경
2. 전략 조건 불러오기 기능 개선
3. 스크리닝 결과를 매매신호로 자동 저장
4. 사용자 경험 개선

---

## ✨ 주요 변경사항

### 1. UI 레이아웃 변경

종목관리 탭과 동일한 좌우 분할 레이아웃으로 변경:

```html
<!-- 왼쪽: 전략 추가 폼 (4칸) -->
<div class="col-md-4">
  <div class="card">
    <div class="card-header">
      <h6><span id="form-title">전략 추가</span></h6>
    </div>
    <!-- 폼 내용 -->
  </div>
</div>

<!-- 오른쪽: 전략 목록 (8칸) -->
<div class="col-md-8">
  <div class="card">
    <div class="card-header">
      <h6>전략 목록</h6>
    </div>
    <!-- 목록 내용 -->
  </div>
</div>
```

### 2. 버튼 레이아웃 개선

**변경 전:**
- 등록 버튼이 폼 하단에 위치

**변경 후:**
- 등록 버튼을 폼 상단으로 이동
- 닫기 버튼 추가 (편집 모드에서만 표시)

```html
<div class="d-flex gap-2 mb-3">
  <button class="btn btn-success flex-fill" onclick="submitStrategy()">
    <i class="fas fa-save"></i> 전략 등록
  </button>
  <button class="btn btn-secondary" onclick="closeStrategyForm()"
          style="display:none;" id="close-btn">
    <i class="fas fa-times"></i> 닫기
  </button>
</div>
```

### 3. 조건 불러오기 기능 개선

#### 원본 데이터 저장
```javascript
// 원본 데이터 저장 (깊은 복사)
originalStrategyData = JSON.parse(JSON.stringify(strategy));
isEditMode = true;
```

#### 변경사항 감지
```javascript
function hasFormChanged() {
  if (!originalStrategyData) return false;

  const currentName = document.getElementById('strategy-name').value;
  const currentDescription = document.getElementById('strategy-description').value;
  const currentConditions = getConditions();

  // 전략명/설명 변경 확인
  if (currentName !== originalStrategyData.name ||
      currentDescription !== (originalStrategyData.description || '')) {
    return true;
  }

  // 조건 변경 확인
  // ... 상세 비교 로직

  return false;
}
```

#### 닫기 시 확인 팝업
```javascript
function closeStrategyForm() {
  if (hasFormChanged()) {
    if (!confirm('변경사항이 있습니다. 저장하지 않고 닫으시겠습니까?')) {
      return;
    }
  }
  resetForm();
  showToast('편집을 취소했습니다.', 'info');
}
```

### 4. 매매신호 연동 기능

#### Backend: Bulk Signal Save API

**router.py** (lines 51-64, 473-539)

Pydantic 모델 정의:
```python
class SignalData(BaseModel):
    ticker: str
    company_name: Optional[str] = None
    country: Optional[str] = 'KR'
    sector: Optional[str] = None
    signal_date: str
    strategy_name: str
    current_price: Optional[float] = None
    target_price: Optional[float] = None
    stop_loss_price: Optional[float] = None
    signal_reason: Optional[str] = None

class BulkSignalsRequest(BaseModel):
    signals: List[SignalData]
```

엔드포인트 구현:
```python
@router.post("/signals/bulk")
async def save_signals_bulk(request: BulkSignalsRequest):
    """스크리닝 결과를 매매 신호로 일괄 저장"""
    try:
        engine = create_engine(DB_URL)
        Session = sessionmaker(bind=engine)
        session = Session()

        saved_count = 0

        for signal_data in request.signals:
            signal_date = datetime.strptime(signal_data.signal_date, '%Y-%m-%d')

            # 중복 체크 (ticker + date + strategy)
            existing = session.query(TradingSignal).filter(
                TradingSignal.ticker == signal_data.ticker,
                TradingSignal.signal_date >= signal_date,
                TradingSignal.signal_date < signal_date.replace(hour=23, minute=59, second=59),
                TradingSignal.reason.like(f'%{signal_data.strategy_name}%')
            ).first()

            if existing:
                continue

            # 새로운 신호 생성
            new_signal = TradingSignal(
                ticker=signal_data.ticker,
                signal_type=SignalType.BUY,
                signal_date=signal_date,
                current_price=signal_data.current_price,
                target_price=signal_data.target_price,
                stop_loss_price=signal_data.stop_loss_price,
                status=SignalStatus.PENDING,
                reason=f"[{signal_data.strategy_name}] {signal_data.signal_reason or '스크리닝 조건 만족'}"
            )

            session.add(new_signal)
            saved_count += 1

        session.commit()
        session.close()

        return {
            "status": "success",
            "message": f"{saved_count}개의 매매 신호가 저장되었습니다",
            "saved_count": saved_count,
            "total_count": len(request.signals)
        }
    except Exception as e:
        logger.error(f"Error saving signals bulk: {e}")
        raise HTTPException(status_code=500, detail=str(e))
```

#### Frontend: 스크린 실행 및 저장

**screening.html**

스크린 실행:
```javascript
async function executeStrategy(strategyName) {
  const startDate = document.getElementById('screen-start-date').value;
  const endDate = document.getElementById('screen-end-date').value;

  if (!startDate || !endDate) {
    showToast('분석 기간을 설정해주세요.', 'warning');
    return;
  }

  try {
    showToast(`'${strategyName}' 전략 실행 중...`, 'info');

    const response = await fetch(
      `${API_BASE_URL}/strategies/${encodeURIComponent(strategyName)}/execute?start_date=${startDate}&end_date=${endDate}`,
      { method: 'POST', headers: { 'Content-Type': 'application/json' } }
    );

    const data = await response.json();

    if (response.ok) {
      await saveToSignals(data, strategyName);
      showToast(`스크리닝 완료! ${data.results.total_matches}개 종목 발견`, 'success');
    }
  } catch (error) {
    showToast('스크리닝 실행 실패: ' + error.message, 'danger');
  }
}
```

매매신호 저장:
```javascript
async function saveToSignals(screeningData, strategyName) {
  const signals = screeningData.results.results.map(stock => ({
    ticker: stock.ticker,
    company_name: stock.company_name,
    country: stock.country || 'KR',
    sector: stock.sector || '',
    signal_date: stock.date,
    strategy_name: strategyName,
    current_price: stock.current_price,
    signal_reason: `스크리닝 조건 만족 (${screeningData.results.total_matches}개 중)`
  }));

  const response = await fetch('/api/trading/signals/bulk', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ signals })
  });

  if (response.ok) {
    const result = await response.json();
    showToast(result.message, 'success');
  }
}
```

---

## 📁 수정된 파일

### Backend
1. **trading_service/router.py**
   - SignalData, BulkSignalsRequest Pydantic 모델 추가
   - POST /api/trading/signals/bulk 엔드포인트 추가
   - 중복 체크 로직 구현

### Frontend
2. **frontend/screening.html** (완전 재작성)
   - UI 레이아웃 변경 (좌우 4:8 분할)
   - 상단 버튼 영역 추가
   - 원본 데이터 저장 및 변경사항 추적
   - 닫기 기능 및 확인 팝업
   - 매매신호 저장 함수 추가

3. **frontend/index.html**
   - 스크리닝 탭 추가 (이전 작업)

### Documentation
4. **docs/INDEX.md**
   - 문서 인덱스 업데이트 (이전 작업)

---

## 🔧 기술 스택

- **Frontend**: Bootstrap 5.1.3, Vanilla JavaScript
- **Backend**: FastAPI, Pydantic
- **Database**: PostgreSQL, SQLAlchemy
- **API**: REST API

---

## ✅ 테스트 시나리오

### 1. 전략 추가 테스트
1. 스크리닝 탭 접속
2. 왼쪽 폼에서 전략명, 설명 입력
3. 조건 추가 버튼으로 조건 블록 생성
4. 지표, 연산자, 값 설정
5. 전략 등록 버튼 클릭
6. 오른쪽 목록에서 전략 확인

### 2. 조건 불러오기 테스트
1. 오른쪽 전략 목록에서 "조건 불러오기" 버튼 클릭
2. 왼쪽 폼에 전략 데이터 로드 확인
3. 폼 타이틀이 "전략 조건 확인/수정"으로 변경 확인
4. 닫기 버튼 표시 확인
5. 조건 값 수정 후 닫기 버튼 클릭
6. 변경사항 확인 팝업 표시 확인

### 3. 스크린 실행 및 매매신호 저장 테스트
1. 분석 기간 설정
2. 전략의 "스크린 실행" 버튼 클릭
3. 스크리닝 실행 중 토스트 알림 확인
4. 완료 후 결과 개수 토스트 확인
5. 매매신호 탭으로 이동
6. 저장된 신호 확인
7. 전략 필터로 해당 전략만 필터링 확인

### 4. 중복 저장 방지 테스트
1. 동일한 전략으로 같은 기간에 두 번 실행
2. 두 번째 실행 시 중복 제외 확인
3. 저장된 신호 개수 확인

---

## 🐛 알려진 이슈

없음

---

## 📝 향후 개선 사항

1. **전략 수정 기능**
   - 현재는 조건 불러오기만 가능
   - 실제 수정 저장 기능 추가 필요

2. **전략 복제 기능**
   - 기존 전략을 기반으로 새 전략 생성

3. **전략 실행 이력**
   - 언제 어떤 전략이 실행되었는지 기록

4. **스크리닝 결과 미리보기**
   - 매매신호로 저장하기 전 결과 확인

5. **일괄 매매신호 관리**
   - 스크리닝으로 생성된 신호 일괄 수정/삭제

---

## 🔗 관련 문서

- [스크리닝백테스팅-가이드-20251007.md](../user-manuals/스크리닝백테스팅-가이드-20251007.md)
- [스크리닝백테스팅시스템-개발-20250924.md](../strategies/스크리닝백테스팅시스템-개발-20250924.md)
- [데이터베이스-가이드-20251007.md](../user-manuals/데이터베이스-가이드-20251007.md)

---

## 💡 참고사항

### Bootstrap 5.1.3 Grid System
```html
<div class="row">
  <div class="col-md-4">왼쪽 (33.33%)</div>
  <div class="col-md-8">오른쪽 (66.66%)</div>
</div>
```

### Toast 알림 사용법
```javascript
function showToast(message, type = 'info') {
  const toastEl = document.getElementById('notification-toast');
  const toastBody = document.getElementById('toast-message');

  toastBody.textContent = message;
  toastEl.className = `toast bg-${type}`;

  const toast = new bootstrap.Toast(toastEl);
  toast.show();
}
```

---

**작성자**: Claude Code
**최종 수정일**: 2025-10-08
**문서 버전**: 1.0
